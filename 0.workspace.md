# JS

###### 去除空格

```js
str.replace(/\s/g,"")	//	去除所有空格
str.trim()	//	去除两端空格
```

###### 手机号或邮箱中间添加‘*’星号

```js
function omitMobile(mobile){
	var reg = /(\d{3})\d{4}(\d{4})/;
	var mphone = mobile.replace(reg,"$1****$2");
	return mphone;
}
omitMobile('15511629409')	//155****9409

function omitEmail(email){
	var reg = /(\\w?)(\\w+)(\\w)(@\\w+\\.[a-z]+(\\.[a-z]+)?)/
	var num = email.indexOf("@");
	var memail = email.substr(0, 3) + '****' + email.substr(num);
	return memail;
}
omitEmail('15511629409111@163.com')		//155****@163.com
```

###### 节流

```js
// 如果对多选进行 节流，为每行添加timer字段
if (this.timer) {
    window.clearTimeout(this.timer);
}
this.timer = window.setTimeout(async () => {
    callback()
}, 300);
```

###### 防抖

```js
const on = Vue.prototype.$on;
Vue.prototype.$on = function(event, func) {
    let timer;
    let newFunc = func;
    if (event === "click") {
        newFunc = function() {
            clearTimeout(timer);
            timer = setTimeout(function() {
                func.apply(this, arguments);
            }, 200);
        };
    }
    on.call(this, event, newFunc);
};
```



# 封装的方法

## 判断数据类型

```js
const _toString = Object.prototype.toString;
/**
 * @description 匹配目标的数据类型
 * @param {any} target  目标
 * @param {string} datatype 预期的类型(常用值：'String' 'Array' 'Object' 'Null' 'Undefined' 'FormData')
 */
export const getDataType = (target, datatype) => 
	Object.is(_toString.call(target).slice(8, -1), datatype);
```

## 判断参数是否为空字符串（去空格）、Null、Undefined

```js
/**
 * @description 判断目标值的类型是否为 "Null"或"Undefined"或"String"且为空（去空格）
 * @param {any} params  目标值
 */
const _filterDataType = params => (
    getDataType(target, 'Null') || 
    getDataType(target, 'Undefined') || 
    (getDataType(target, 'String') && target.trim() === ""))
```

## 过滤目标对象中指定的值

```js
/**
 * @description 过滤目标对象(去除value值为"Null"或"Undefined"或"String"且为空（去空格）)
 * @param {Object} params 过滤的目标对象Object
 */
export const filterParams = params => {
    let obj = {}
    Object.keys(params).map(key => (!_filterDataType(params[key]) && (obj[key] = params[key])))
    return obj
}
```

## 获取目标值或目标对象key值

```js
/**
 * @description 获取目标值或目标对象key值
 * @param {any} target  string/object
 * @param {string} key  不传/string
 * @example getTargetVal('key') || getTargetVal(targetObj, 'key')
 */
export const getTargetVal = (target, key) => 
    _filterDataType(target)
        ? "--"
        : Object.is(key, undefined)
            ? target
            : _filterDataType(target[key])
                ? "--"
                : target[key];
```

## 获取目标常量的key值

```js
/**
 * @description 获取目标常量的key值
 * @param {string} constant 常量
 * @param {string} target   要匹配的目标值，一般都是string类型
 * @param {string} key  要返回的目标key的值
 * @example getTargetConst('CONSTANT', '0', 'label')
 */
export const getTargetConst = (constant, target, key) => {
	if (_filterDataType(target)) { return "--" }
    if (getDataType(target,"String")) {
        let arr = CONSTANT[constant].filter(v => v.value === target)
        return arr.length === 0 ? "--" : arr[0][key]
     }
};
```

## 浏览器复制功能

原理：把要复制的目标值 赋值 给临时创建的input元素，使用doocument的复制命令来实现复制功能

```js
/**
 * @param {string} value 要复制的目标值
 */
export const copy = value => {
  let ipt = document.createElement("input");
  ipt.value = value;
  document.body.appendChild(ipt);
  ipt.select(); // 选择input对象
  document.execCommand("Copy"); // 执行浏览器复制命令
  ipt.style.display = "none";
};
```

## 时间格式化

```js
/**
 * @description 把时间戳转成不同的时间格式
 * @param {number} timeStamp 时间戳
 * @param {any} flag 默认不写，可选值 1, 2, 3
 * @example timeFormat(+new Date(), 1)
 */
export const timeFormat = (timeStamp, flag) => {
  let year = new Date(timeStamp).getFullYear();
  let month = (new Date(timeStamp).getMonth() + 1 < 10) 
  			? ("0" + (new Date(timeStamp).getMonth() + 1)) : (new Date(timeStamp).getMonth() + 1);
  let day = (new Date(timeStamp).getDate() < 10) 
  			? ("0" + new Date(timeStamp).getDate()) : new Date(timeStamp).getDate();
  let hours = (new Date(timeStamp).getHours() < 10) 
  			? ("0" + new Date(timeStamp).getHours()) : new Date(timeStamp).getHours();
  let minutes = (new Date(timeStamp).getMinutes() < 10) 
  			? ("0" + new Date(timeStamp).getMinutes()) : new Date(timeStamp).getMinutes();
  let seconds = (new Date(timeStamp).getSeconds() < 10) 
  			? ("0" + new Date(timeStamp).getSeconds()) : new Date(timeStamp).getSeconds();

    switch (flag) {
        case 1:
            return `${year}-${month}-${day}`; //  YY-MM-DD
        case 2:
            return `${year}${month}${day}${hours}${minutes}${seconds}`; //  YYMMDDHHMMSS
        case 3:
            return `${month}-${day}`; //  MM-DD
        default:
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`; //  YY-MM-DD HH:MM:SS
    }
};
```



# vue

## 自定义方法传参

主要是针对该方法有默认参数的情况下进行传参（正常传参默认会覆盖默认参数，所以通过闭包来实现自定义传参）

```js
@change="((val)=>{change(val, key)})"	
```

## 使用通过script引入的库

```js
// html
<script type="text/javascript" src="<%= BASE_URL %>js/aes.js"></script>
<script type="text/javascript" src="<%= BASE_URL %>js/rsa.js"></script>
// vue.config.js
configureWebpack: {
    externals: {
      JSEncrypt: "JSEncrypt",
      CryptoJS: "CryptoJS"
    }
  },
// 使用
import JSEncrypt from "JSEncrypt";
import CryptoJS from "CryptoJS";
```







# encrypt

原理：通过AES（对称）和RSA（非对称）加密解密

## AES对称加解密

```js
import CryptoJS from "CryptoJS";

const AES_KEY = "987654321ccp9102";// 16位
// 加密
export const _encryptParams = params => {
    let key = CryptoJS.enc.Utf8.parse(AES_KEY);
    let encryptedData = CryptoJS.AES.encrypt(params, key, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
    return encryptedData.toString();
};

// 解密
export const _decryptParams = params => {
    let key = CryptoJS.enc.Utf8.parse(AES_KEY);
    let decryptedData = CryptoJS.AES.decrypt(params, key, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });

    return CryptoJS.enc.Utf8.stringify(decryptedData).toString();
};
```



## 请求方式及参数类型的判断

### GET

params：Object

加密前：Object

加密后：Object

### POST

+ data: Object（序列化， requestParameter接收，进入parameter）

  加密前：.遍历对象，只对value加密

  加密后：String（`data = qs.stringify(data)` 序列化处理）

+ data: Object（JSON对象，requestBody接收，进入bodyMap）

  加密前：.遍历对象，只对value加密

  加密后：Object

  | value数据类型     |      注意事项（前三种可通过`filterParams`方法遍历过滤）      |
  | :---------------- | :----------------------------------------------------------: |
  | 1、空字符串（""） |   如果没有默认值或不是必传参数，可把默认值设为==空字符串==   |
  | 2、null对象       | 没有特殊情况，不要赋值为null对象，否则会被解密为"null",（基本不存在） |
  | 3、undefined      | 如果该字段不是必填项，后端没有默认值，前端没有赋值时，相当于此value=undefiend，所以要么赋值 ，要么不传此参数 |
  | 4、Array/Object   |                加密前：JSON.stringify(params)                |

+ data：Array（后端requestBody接收，进入bodyMap，需要设置"Content-type"）

  加密前：（设置类型必须写在加密前，否则无效）

  + `data = JSON.stringify(data)`
  + 如果设置："Content-type": "application/json; charset=utf-8"（后端为body接收）

  + ==如果不设置："Content-type": "application/json; charset=utf-8"，参数类型会转为FormData类型（后端是进入params还是body取决于两者判断的顺序）==

  加密后：String

  ```js
  // 示例：如果data的值是String，必须在头部设置"Content-type"才不会进入后端params
  this.$https.post(url, {data: JSON.stringfy(data)}, 
            {headers:{"Content-type": "application/json; charset=utf-8"}})
  ```

  

+ data：FormData（主要是针对文件上传，requestParameter接收，进入parameter）

  加密前：需要对formData对象进行遍历加密，否则会对FormData对象加密

  加密后：需要重新添加到formData对象中，否则加密后的数据类型不是formData类型

  ```js
  let formData = new FormData();
  for (let item of params.entries()) {
      if (!getDataType(item[1], 'File')) {
          formData.append(item[0], value);
      } else {
          formData.append(item[0], item[1]);
      }
  }
  ```

  

### PUT

==只有对象（key,value）才会进入到bodyMap里==

+ data：Object/Array（进requestBody接收，但不进入bodyMap，需要单独处理）

  加密前：String（`params = qs.stringify(params)` 序列化）

  加密后：String

+ data：FormData（主要是针对文件上传，requestParameter接收，进入parameter）

  加密前：需要对formData对象进行遍历加密，否则会对FormData对象加密

  加密后：需要重新添加到formData对象中，否则加密后的数据类型不是formData类型

+ data: Object（JSON对象，requestBody接收，进入bodyMap）

  加密前：.遍历对象，只对value加密

  加密后：Object

  

  | value数据类型     |      注意事项（前三种可通过`filterParams`方法遍历过滤）      |
  | :---------------- | :----------------------------------------------------------: |
  | 1、空字符串（""） |   如果没有默认值或不是必传参数，可把默认值设为==空字符串==   |
  | 2、null对象       | 没有特殊情况，不要赋值为null对象，否则会被解密为"null",（基本不存在） |
  | 3、undefined      | 如果该字段不是必填项，后端没有默认值，前端没有赋值时，相当于此value=undefiend，所以要么赋值 ，要么不传此参数 |
  | 4、Array/Object   |                加密前：JSON.stringify(params)                |

### DELETE

==目前数据类型都为requestBody接收，进入bodyMap==

+ data：Object（进requestBody接收，但不进入bodyMap，需要单独处理）

  加密前：

  + `params = qs.stringify(params)` 序列化
  + 设置："Content-type": "application/x-www-form-urlencoded;charset=UTF-8"（后端为body接收）

  加密后：String

+ data：Array （进requestBody接收，但不进入bodyMap，需要单独处理）

  加密前：

  + `params = JSON.stringify(params)` 
  + 设置：`"Content-type": "application/json;charset=UTF-8"`（后端为body接收）

  加密后：String

+ data：Object（进requestBody接收，进入bodyMap）
  
  加密前：对value加密
  
  加密后：Object

# 优化

## 开启Gzip压缩

1. 安装：`npm install compression-webpack-plugin --save`
2. 配置

```js
// vue.config.js
const CompressionPlugin = require('compression-webpack-plugin')
module.exports = {
  configureWebpack: config => {
    let plugins = {}
    if(process.env.NODE_ENV === 'production') {
        plugins['plugins'] = [new CompressionPlugin({
            test: /\.js$|\.html$|\.css/,
            threshold: 10240, //  对大于10K的数据进行压缩
            deleteOriginalAssets: false,  //  不删除原文件
        })]
    }
    return plugins
  }
}
```

3. node.js服务器启用Gzip

   + 安装：`npm install compression`

   + 配置

     ```js
     const compression = require('compression')
     const app = express();
     
     //尽量在其他中间件前使用compression
     app.use(compression());
     ```

     



# axios

## 请求封装

## 取消请求

```js
// 第一步：请求拦截（把当前页面上所有请求API存储起来）
let CancelToken = axios.CancelToken;
axios.interceptors.request.use(
    config => {
        config.cancelToken = new CancelToken(c => {
            Vue.prototype.__cancels__.push(c);
        });
        return config;
    }
);
// 第二步：响应拦截（请求取消后，请求响应会被错误拦截并抛出异常，需要对其处理）
axios.interceptors.response.use(
    response => {},
    error => {
        if (axios.isCancel(error)) {
            Promise.resolve(error);	//	不执行
            Promise.reject(error);	//	会抛出异常
        } else if (error.response) {
            // 处理不同的状态
        }
        return Promise.reject(error);
    }
);
// 第三步：路由拦截（路由跳转之前，把之前页面处于pending状态的API全部取消）
Vue.prototype.__cancels__ = [];
router.beforeEach((to, form, next) => {
    Vue.prototype.__cancels__.forEach(cancel => {
        cancel();
    });
    Vue.prototype.__cancels__ = [];
    next();
});
// 第四步：因为所有API请求都是异步请求，所以必须改变请求的状态，否则会报异步请求异常（示例：如下）
1、终止单个请求
async request() {
    return await https
        .get(url, { params })
        .then(async res => {
        	awiait request()
        // do something....
    })
2、 终止循环请求
async loop() {
    for (let key in object) {
        await https
            .get(url, { params })
            .then(res => {
            	// do something....
        	})
    }
    return;
},
```

# BUG

## 表单

1、<form></form> 中只有一个TextBox输入框时，当输入完成后，==按回车键会自动提交==，便刷新了页面

解决方法：<form @submit.native.prevent></form>或<form onsubmit="return false;"></form>

## es6

1、不能把==forEach/map/reduce==和==async/await==用在一起

forEach/map/reduce：它是同步的，它们代替for循环，但牺牲代码的直观性，提升代码的简洁性

**async/await 语法糖本身就是为了避免回调函数这种“不直观”的逻辑，将异步回调转成同步顺序执行，从而使得代码符合直观的理解**

**另一个角度await后面要接的是异步操作，而foreach是同步操作并发操作，也就是说无论await是在foreach里面还是await后面接foreach都不行**























