<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    body {
      text-align: center;
    }
  </style>
</head>
<body>
  <p>注：此图基于d3-v5版本</p>
  <!-- 知识点：
    d3.forceSimulation():创建力导向图

    d3.forceSimulation().force():添加或移除一个力

    d3.forceSimulation().nodes([nodes]):数据转换（参数是数组)

    d3.forceLink.links()

    tick函数:这个函数对于力导向图来说非常重要，因为力导向图是不断运动的，每一时刻都在发生更新，所以需要不断更新节点和连线的位置

    d3.drag():力导向图可以被拖动
  -->
</body>
</html>
<script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
<script>
// ------------数据准备---------------
let width = 960,
    height = 560,
    padding = 20 // 画布内边距
//  创建svg画布
let svg = d3.select('body')
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('background', '#ccc')
// 创建分组<g>来存储图像
let g = svg.append('g')
           .attr('transform','translate(' + padding + ',' + padding + ')')

//准备数据
let nodes = [//节点集
  { name: "湖南邵阳" },
  { name: "山东莱州" },
  { name: "广东阳江" },
  { name: "山东枣庄" },
  { name: "泽" },
  { name: "恒" },
  { name: "鑫" },
  { name: "明山" },
  { name: "班长"}
]
let edges = [//边集
  { source: 0, target: 4, relation: "籍贯", value: 1.3 },
  { source: 4, target: 5, relation: "舍友", value: 1 },
  { source: 4, target: 6, relation: "舍友", value: 1 },
  { source: 4, target: 7, relation: "舍友", value: 1 },
  { source: 1, target: 6, relation: "籍贯", value: 2 },
  { source: 2, target: 5, relation: "籍贯", value: 0.9 },
  { source: 3, target: 7, relation: "籍贯", value: 1 },
  { source: 5, target: 6, relation: "同学", value: 1.6 },
  { source: 6, target: 7, relation: "朋友", value: 0.7 },
  { source: 6, target: 8, relation: "职责", value: 2}
]
// ----------比例尺(不同色)--------------
let colorScale = d3.scaleOrdinal()
                   .domain(d3.range(nodes.length))
                   .range(d3.schemeCategory10)
// ----------创建力导向图-----------------
let forceSimulation = d3.forceSimulation()
                        .force('link', d3.forceLink())
                        .force('change', d3.forceManyBody())
                        .force('center', d3.forceCenter())
// 生成节点数据
forceSimulation.nodes(nodes).on('tick', ticked)
// 生成边集数据
forceSimulation.force('link')
               .links(edges)
               .distance( function (d) {
                 return d.value * 100
               })
// 设置图形中心位置
forceSimulation.force('center').x(width/2).y(height/2)
//-----------绘图-------------------------
let links = g.append('g')
             .selectAll('line')
             .data(edges)
             .enter()
             .append('line')
             .attr('stroke', function (d, i) {
               return colorScale(i)
             })
             .attr('stroke-width', 1)
// 边上的文字
let linksText = g.append('g')
                 .selectAll('text')
                 .data(edges)
                 .enter()
                 .append('text')
                 .text(function (d) {
                   return d.relation
                 })
//  建立用来放在每个节点和对应文字的分组<g>
let gs = g.selectAll('.circleText')
          .data(nodes)
          .enter()
          .append('g')
          .attr('transform', function (d, i) {
            return 'translate(' + d.x + ',' + d.y + ')'
          })
          .call(d3.drag().on("start",started).on("drag",dragged).on("end",ended))
// 绘制节点与文字
gs.append('circle')
  .attr('r', 10)
  .attr('fill', function (d, i) {
    return colorScale(i)
  })
gs.append('text')
  .attr('x', -10)
  .attr('y', -20)
  .attr('dy', 10)
  .text(function (d) {
    return d.name
  })
//----------- ticked函数 ---------------
function ticked () {
  links.attr("x1", function (d) { return d.source.x })
       .attr("y1", function (d) { return d.source.y })
       .attr("x2", function (d) { return d.target.x })
       .attr("y2", function (d) { return d.target.y })

  linksText.attr("x", function(d) { return (d.source.x + d.target.x) / 2})
           .attr("y", function(d) { return (d.source.y + d.target.y) / 2  })

  gs.attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")" })
}
// drag
function started (d) {
  if(!d3.event.active){
    forceSimulation.alphaTarget(0.8).restart();//设置衰减系数，对节点位置移动过程的模拟，数值越高移动越快，数值范围[0，1]
  }
  d.fx = d.x
  d.fy = d.y
}
function dragged (d) {
  d.fx = d3.event.x
  d.fy = d3.event.y
}
function ended (d) {
  if(!d3.event.active){
    forceSimulation.alphaTarget(0);
  }
  d.fx = null
  d.fy = null
}






</script>