# 总结

## 循环遍历

|              名称              |                           遍历对象                           |                             缺点                             |                     优点                     |
| :----------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :------------------------------------------: |
|              for               |                         数组和类数组                         |                      嵌套多层，难以维护                      |                                              |
|            forEach             |                        数组(自带方法)                        | 无法中间跳出循环（不支持==break==、==continue==操作，如若数组成员很多，将无法终止遍历来节省资源 |                                              |
|             for-in             | 所有可枚举属性（包括对象自身的和原型上添加的和继承的）(不含Symbol属性)，能够遍历==对象==、==数组==、==字符串==，支持==break==、==continue==操作 | 会遍历原型上可枚举属性，需要通过==obj.hasOwnProperty(attr)==来过滤掉 |                                              |
|             for-of             | Array（数组）, String（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等 |                                                              |                                              |
|         Object.keys()          | 获取到对象实例的所有可枚举属性，其返回值为一个数组，数组元素为对象的==键名== | 因为它是es5的写法，所以只能遍历对象，非对象（如字符串）就会报错，但es6不会报错 | 它不会获取对象自身不可枚举属性和原型上的属性 |
|  Object.getOwnPropertyNames()  |        获取==键名==数组，能够获取对象的不可枚举的属性        |                                                              |                                              |
|        Object.entries()        |                      获取==键值对==数组                      |                                                              |                                              |
|        Object.values()         |                   获取对象的==属性值==数组                   |                                                              |                                              |
| Object.getOwnPropertySymbols() | ==获取Symbol属性名==，以上几种方法都无法遍历Symbol类型的对象，只能通过此方法来获取 |                                                              |                                              |

### for-of

+ 语法

  ```js
  for(variable of iterable){statement}
  //variable：每个迭代的属性值被分配给该变量。
  //iterable：一个具有可枚举属性并且可以迭代的对象。
  ```

+ 示例

  + 数组

    ```js
    const iterable = ['mini', 'mani', 'mo'];
     
    for (const value of iterable) {
      console.log(value);	//	'mini', 'mani', 'mo'
    }
    ```

  + Map对象

    ```js
    const iterable = new Map([['one', 1], ['two', 2]]);
     
    for (const [key, value] of iterable) {
      console.log(`Key: ${key} and Value: ${value}`);
    }
    // Key: one and Value: 1
    // Key: two and Value: 2
    ```

  + Set对象

    ```js
    const iterable = new Set([1, 1, 2, 2, 1]);
     
    for (const value of iterable) {
      console.log(value);// 1	2
    }
    ```

  + String

    ```js
    const iterable = 'javascript';
     
    for (const value of iterable) {
      console.log(value);	//	'j' 'a' 'v' 'a' 's' 'c' 'r' 'i' 'p' 't'
    }
    ```

  + Arguments Object(参数对象)

    ```js
    function args() {
      for (const arg of arguments) {
        console.log(arg);	//	a	b	c
      }
    }
    args('a', 'b', 'c');
    ```



## 数组去重

- 方法一：利用indexOf()或lastIndexOf()或includes()来筛选

  ```js
  (function unique (arr) {
      let temp = []
      //遍历目标数组（也可用for循环，forEach,filter）
      arr.map((v,k) => {
          // 利用空数组来判断某个元素是否存在，若存在，直接跳过，否则添加至空数组中
          // IE8以下不支持数组的indexOf方法
          if (temp.indexOf(v) === -1) temp.push(v)
          //if (temp.lastIndexOf(v) === -1) temp.push(v)
          //if (!temp.includes(v)) temp.push(v)
      })
      return temp
  })([2,2,3,3,'2','4'])
  ```

- 方法二：

  - 利用对象属性是否存在的特性筛选，但也有例外（如obj[1],obj['1']会被误认为是一样的）
  - 筛选相同数值，不同数据类型，通过indexOf来判断

  ```js
  (function (arr) {
      let obj = {}, temp = []
      //遍历目标数组（也可用for循环）
      arr.map((v,k) => {
          let type = typeof v
          if (!obj[v]) {
              obj[v] = [type]
              temp.push(v)
          } else if (obj[v].indexOf(type) === -1) {
              obj[v].push(type)
              temp.push(v)
          }
      })
      return temp
  })(['2',1,2,5,1,5,'1'])
  ```

- 方法三：利用splice(k,1)来删除重复值

  ```js
  (function (arr) {
      for (let i = 0; i < arr.length; i++) {
          for (let j = i + 1; j < arr.length; j++) {
              if (arr[i] === arr[j]) {
                  arr.splice(j, 1)
                  j--
              }
          }
      }
      return arr
  }(['2',1,2,5,1,5,'1']))
  ```

- 方法四：es6写法

  ```js
  (function unique (arr) {
      return Array.from(new Set(arr))
  })(['2',1,2,5,1,5,'1'])
  ```



## 排序

### 快速排序

```.js
var arr = [12,1,23,412,22,13,43]
function quickSort (arr) {
    if (arr.length <= 1) return arr
    // 中间值的索引值
    var index = Math.floor(arr.length / 2)
    var temp = arr.splice(index, 1)
    var left = [], right = []
    for (var i = 0; i <= arr.length - 1; i++) {
        if (arr[i] < temp) {
            left.push(arr[i])
        } else {
            right.push(arr[i])
        }
    }
    return quickSort(left).concat(temp,quickSort(right))
}
```



# 数据类型

## 基本类型

- 字符串类型：String
- 数字类型：Number
- 布尔类型：Boolean
  - ==为false的情况：0、-0、null、“ ”、false、undefined、NaN==
- 未定义类型：Undefine
- 空类型：null
- Symbol(es6新增，暂不考虑)

## 基本包装类型和引用类型的区别

### 基本包装类型

==string、number、boolean这三个基本类型都有自己的包装对象，有相应的属性和方法==

==生存期：执行一行代码的瞬间之后就会立即销毁，所以我们无法直接给基本类型添加方法，只能通过原型对象来添加==

```js
var str = 'hello';
str.number = 10; //假设我们想给字符串添加一个属性number ，后台会有如下步骤
｛ 
    var _str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象
    _str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存
    _str =null; // 3 这个对象又被销毁
｝
	alert(str.number); //undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤
｛ 
    var str = new String('hello'); // 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为hello对象
    str.number = undefined   // 2 因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定义;然后弹出结果
    str =null; // 3 这个对象又被销毁
｝
```

### 引用类型

==生存期：使用new创建引用类型的实例，在执行数据流离开当前作用域时会一直存储在内存中==

- 对象类型：Object(包括Array、Date等)

## 值类型和引用类型区别

==代码存储在磁盘，但是要执行代码时需要先加载到内存。而内存分两块:堆 和 栈==

- 值类型：string ,number ,boolean ,(undefined (null))

​      它存储栈中，并且存储的是数据本身的值

​      <em>注：null返回的是object，存在一定争议</em>

​          console.log(typeof undefined);//输出undefined

​          console.log(typeof null);//输出object

- 引用类型：object

​      存储在栈中，存储的是内存地址，该地址指向的是在堆中的地址，数据也在堆中

```js
var a = 10;//值类型
var b = {x:1};//引用类型
var c = a;//把a的数据赋值给c
c = 20;//重新给c赋值，直接取代之前的赋值
console.log(a);//10

c = b;//把b的数据赋值给c，但此数据为存储在栈中的地址
c.x = 2;//改变此地址所指向堆中的数据
console.log(b.x);//2

```

## 数据类型转换

- 数字转字符串：+/toString()
- 转整数数字：parseInt()
- 转浮点数字：parseFloat()

## 数据类型判断

typeof

instanceof

Object.prototype.toString

# JavaScript基础

## 运算符

### +

加法运算、字符串拼接、数字转换字符串

它只能作用于字符串数值，否则就会返回 NaN（不是数字）

```js
console.log(+new Array(0))	0
console.log(+new Array(10))	NaN
console.log(+[])	0	
console.log(+[0])	1
console.log(+[1111])	1111
console.log(+[1,2,3])	NaN	
console.log(+new Date())	1542860532472
```

- -、*、/、%、++、--：算术运算符
- =：赋值运算符
- <、<=、>、>=：比较运算符
- ==、!=：比较运算符（只比对内容，不对比类型）
- `===` 、`!==`：比较运算符（严格比对，包括内容和类型）
- &&、||、！：逻辑运算符（与、或、非）

### &&

```js
if (token) {
    getUser();
}
//可以简写为
token && getUser();
```

### ||

```js
var token = token || "XXXXXXXXXX";// 设置默认值	
```

### !!

!! 可以将变量转换为布尔值

!! 可以把任何类型的值转换为布尔值，并且只有当这个变量的值为 0 / null / "" / NaN / undefined 的时候才会返回 false，其他情况都返回 true

```js
console.log(!!'' )    // false
console.log(!!' ')    // true
console.log(!!0)      // false
console.log(!!null)   // false
console.log(!!undefined)    // false
console.log(!!NaN)    // false
console.log(!!123)    // true
console.log(!![])     // true
```



## 流程控制语句

- 判断语句

  <!-- if和switch的区别：if可以做等值判断也可以做区间判断，swithc只能做区间判断，但语句比较简洁 -->

  - if(条件:true){...}，if(){...}else{...},if(){...}else if(){...}
  - switch(判断的目标){case 1:语句1;break;  case 2:语句2;break; ...  default:最后一个执行语句;}
  - 三目运算符：（a？b：c）只有只判断一次的情况下才使用。如果a为真，执行b语句，否则执行c语句

- 循环语句
  - 循环三要素：1、开始（初始值）2、结束（终止条件）3、计数（递增/递减）
  - 嵌套循环特点：外层循环一次，内层循环全部
  - while(条件:true){...}：先判断后执行
  - do{...}while(条件:true)：先执行后判断
  - for(初始值;结束条件;计数){执行语句}
  - 控制循环：break：跳出循环（结束循环）、continue：跳过此条件循环（继续下一次循环）、return：返回且中止

## 异常处理

try (throw) catch  finally

```js
try{

    console.log("我试着做一件事情!");

    throw "我是一个故意的错误"; //throw可以抛出异常

    console.log("我试着做第二件事情!");

}catch(e){//抓取异常

    console.log("处理异常");

}finally{

    console.log("这是finally的语句,无论成功与否都会执行!");

}

```

## 参数

1. 实参：函数调用时实际传入的参数

1. 形参：函数声明的时候，用来占位的变量名，没有具体数值，但当函数调用时，会默认将实参的值赋值给形参

- 值类型参数

  ```js
  var num = 100;//此num为实参
  function add(num) { num = 200;}//此num为形参
  add(num);//传入实参num并赋值给形参num
  console.log(num);//100，值类型的赋值互相是独立的
  ```

- 引用类型参数：

  ==注：如果在函数内部对形参重新赋值，那么形参和外面的实参就不在指向同一个对象。修改其中一个，也就不会影响另外一个==

  ```js
  var obj = {id : 10};//字面量对象
  function fn(param) { param.id = 20;}
  fn(obj);//将对象当参数传入并把实参地址赋值给形参
  console.log(obj.id)//20;引用类型的赋值是地址，它们指向同一对象
  ```

##   严格模式

ES5

+ 变量必须声明后再使用
+ 函数的参数不能有同名属性，否则报错
+ 不能使用with语句
+ 不能对只读属性赋值，否则报错
+ 不能使用前缀0表示八进制，否则报错
+ 不能删除不可删除的属性，否则报错
+ 不能删除变量delete prop，否则报错，只能删除属性delete global[prop]
+ eval不会在它外层作用域引入变量
+ eval和arguments不能被重新赋值
+ arguments不会自动反映函数参数的变化
+ 不能使用arguments.callee和arguments.caller
+ 禁止this指向全局对象
+ 不能使用fn.caller和fn.arguments获取函数调用的堆栈
+ 增加了保留字（eg：protected、static、interface）

# JavaScript执行机制

[参考api](https://juejin.im/post/59e85eebf265da430d571f89)

## 单线程（异步）

javascript是一门单线程语言，所谓多线程也是用单线程模拟出来的，即不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的

## javascript的执行和运行

执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的

## 事件循环（Event Loop）

事件循环是js实现异步的一种方法，也是js的执行机制

网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务

+ 同步任务

+ 异步任务

![](E:\web\Typora\img\同步异步.png)

导图文字描述：

+ 同步和异步任务分别进入不同“场所”，同步会进入主线程，异步会进入Event Table并注册回调函数
+ 异步指定的事情完成时，Event Table（事件表）会将这个函数移入Event Queue（事件队列）
+ ==主线程的任务执行完毕后为空，就会去Event Queue读取对应的函数，进入主线程执行==
+ 不断重复上述步骤，即Event Loop(事件循环)

==任务又细分为宏任务和微任务，不同类型的任务会进入对应的Event Queue==

+ macro-task(宏任务)：包括整体代码script，setTimeout，setInterval

  + setTimeout(fn,0)

    指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行

    关于`setTimeout`要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒

  + setInterval（fn,ms）

    不是每过`ms`秒会执行一次`fn`，而是每过`ms`秒，会有`fn`进入Event Queue。一旦**setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了**

+ micro-task(微任务)：Promise，process.nextTick

  + Promise(参考es6)

  + process.nextTick(callback)

    `process.nextTick(callback)`类似node.js版的"setTimeout"，在事件循环的下一次循环中调用 callback 回调函数

==导图分析==

+ ==整体代码==会作为第一个宏任务，进入主线程
+ 如遇到==宏任务（指setTimeout等）==会将其回调函数注册后发到==宏任务Event Queue==
+ 如遇到==微任务（指Promise等）==会将其回调函数注册后发到==微任务Event Queue==
+ 第一个宏任务执行结束后，会去执行微任务（存在），执行完毕
+ 第二次循环将从==宏任务Event Queue==开始，即第二个宏任务

==第一个宏任务（整体代码）——>第一个宏任务中微任务——>第二个宏任务（第一个宏任务中的宏任务Event Queue）——第二个宏任务中的微任务==

![](E:\web\Typora\img\宏任务和微任务.png)

## 示例详解

```js
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() {
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})
```

示例代码解析：

- ==整体script作为第一个宏任务进入主线程==，遇到`console.log`，输出1。
- 遇到`setTimeout`，其回调函数被分发到宏任务Event Queue中。我们暂且记为`setTimeout1`。
- 遇到`process.nextTick()`，其回调函数被分发到微任务Event Queue中。我们记为`process1`。
- 遇到`Promise`，`new Promise`直接执行，输出7。`then`被分发到微任务Event Queue中。我们记为`then1`。
- 又遇到了`setTimeout`，其回调函数被分发到宏任务Event Queue中，我们记为`setTimeout2`。

| 宏任务Event Queue | 微任务Event Queue |
| ----------------- | ----------------- |
| setTimeout1       | process1          |
| setTimeout2       | then1             |

- 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。
- 我们发现了`process1`和`then1`两个微任务。
- 执行`process1`,输出6。
- 执行`then1`，输出8。

第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么==第二轮时间循环从`setTimeout1`宏任务开始==：

- 首先输出2。接下来遇到了`process.nextTick()`，同样将其分发到微任务Event Queue中，记为`process2`。`new Promise`立即执行输出4，`then`也分发到微任务Event Queue中，记为`then2`。

| 宏任务Event Queue | 微任务Event Queue |
| ----------------- | ----------------- |
| setTimeout2       | process2          |
|                   | then2             |

- 第二轮事件循环宏任务结束，我们发现有`process2`和`then2`两个微任务可以执行。
- 输出3。
- 输出5。
- 第二轮事件循环结束，第二轮输出2，4，3，5。
- ==第三轮事件循环开始==，此时只剩setTimeout2了，执行。
- 直接输出9。
- 将`process.nextTick()`分发到微任务Event Queue中。记为`process3`。
- 直接执行`new Promise`，输出11。
- 将`then`分发到微任务Event Queue中，记为`then3`。

| 宏任务Event Queue | 微任务Event Queue |
| ----------------- | ----------------- |
|                   | process3          |
|                   | then3             |

- 第三轮事件循环宏任务执行结束，执行两个微任务`process3`和`then3`。
- 输出10。
- 输出12。
- 第三轮事件循环结束，第三轮输出9，11，10，12。

整段代码，共进行了==三次事件循环==，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。
(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)

# 事件处理机制

事件处理机制：事件流、事件监听、事件委托、事件源、事件对象 

## 一、事件流：冒泡型和捕获型

```
  1、冒泡型 ：所有浏览器都支持，从所触发的元素往上一直到最外层元素

    目前低版本的IE浏览器还是只能支持冒泡流(IE6,IE7,IE8均只支持冒泡流)，所以为了能够兼容更多的浏览器，建议使用冒泡流

  2、捕获型 ：标准DOM浏览器都支持，从最上层元素向下一直到所触发的元素为止

```

![事件流原理图](E:\web\\Typora\img/事件流原理图.png)

## 二、事件监听

### 监听事件方法

 IE浏览器下处理事件监听，事件名不需去掉“on”，由于IE只支持冒泡事件，所以没有第三个参数

1. attachEvent("事件名",执行的函数)：添加监听事件（主要针对IE浏览器）
2. detachEvent("事件名",执行的函数)：取消监听事件       

 标准DOM来处理事件监听方法（必须把事件名前的“on”给去掉） 

1. addEventListener("事件",函数,true/false)：添加事件（true为捕获型，false为冒泡型    
2. removeEventListener("事件",函数，true/false)：取消监听（true为捕获型，false为冒泡型）

### stopPropagation()与preventDefault()的区别

1. preventDefault()主要是用来阻止标签的默认行为
2. stopPropagation()这个方法主要是用来阻止事件冒泡的，也能阻止了事件的继续捕获

在IE浏览器上面是event事件是没有preventDefault()和stopPropagation()属性的，所以在IE上，我们需要设置的属性是returnValue和cancelBubble

1. preventDefault()在IE浏览器下的用法如下：window.event.returnValue=false;
2. stopPropagation()在IE浏览器下的用法如下：window.event.cancelBubble=true;

### target与currentTarget

target属性指向的是目标过程中的DOM对象，currentTarget指向的是当前的对象，具体内容跟this一样，所以当this指向的是目标的时候，target与currentTarget相同

```js
btn.onclick = function (e) {
    //this=target=currentTarget
    console.log(e.target === this)//true
    console.log(e.currentTarget === this)//true
    console.log(e.target === e.currentTarget);//true
}
```

## 三、事件源

在事件中，当前操作的那个元素就是事件源

1. IE获取事件源方法：window.event.srcElement  
2. 标准下：event.target

## 四、事件委托或事件代理

1. 为什么要用事件委托

   - 问题1：在业务中，当事件涉及到更新HTML节点或者添加HTML节点的时候，就会出现这样的一种情况，新添加的节点无法绑定事件，更新的节点也是无法绑定事件，表现的行为是无法触发事件
   - 问题2：每当将事件处理程序制定给元素时，运行中的浏览器代码与支持页面交互的JS代码之间就会建立一个连接，而这种连接越多，页面执行起来就越慢。考虑内存和性能问题，为了解决事件处理程序过多的问题，采用事件委托变得很有必要。

2. 简单的事例

   有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。

   - 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；
   - 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。

3. 事件委托的原理：利用事件的冒泡原理来实现

   解决方法：因为冒泡机制，比如既然点击子元素，也会触发父元素的点击事件，那我们完全可以将子元素的事件要做的事写到父元素的事件里，也就是将子元素的事件处理程序写到父元素的事件处理程序中，这就是事件委托；利用事件委托，只指定一个事件处理程序，就可以管理某一个类型的所有事件

   - 因为把事件绑定到了父节点上，因此省了绑定事件。就算后面新增的子节点也有了相关事件，删除部分子节点不用去销毁对应节点上绑定的事件

   - 父节点是通过event.target来找对应的子节点的。（事件处理程序中的this值始终等于currentTarget的值，指向的是绑定到的那个元素）

     适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。

     mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要经常计算它们的位置，处理起来不太容易。

## 五、事件对象

获取事件对象的方法：var e = event || window.event

1. 鼠标事件对象上的常用属性：
   - clientX：当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等），鼠标相对于浏览器（这里说的是浏览器的有效区域）x轴的位置
   - clientY：当鼠标事件发生时，鼠标相对于浏览器（这里说的是浏览器的有效区域）y轴的位置
   - screenX：当鼠标事件发生时，鼠标相对于显示器屏幕x轴的位置
   - screenY：当鼠标事件发生时，鼠标相对于显示器屏幕y轴的位置
   - offsetX：当鼠标事件发生时，鼠标相对于事件源x轴的位置
   - offsetY：当鼠标事件发生时，鼠标相对于事件源y轴的位置
2. 键盘事件对象上的属性有：
   - keyCode: 用来获取键盘码的;比如空格的键盘是32，回车13等
   - cltkey: 判断alt键是否被按下，按下是true，反之false
   - Ctrlkey: 判断Ctrlkey键是否被按下，按下是true，反之false
   - Shiftkey : 判断Shiftkey 键是否被按下，按下是true，反之false

```js
var EventUtil = {
    /*添加事件监听*/
    addHandler: function (element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent(on + type, handler);
        } else {
            element['on' + type] = handler;
        }
    },
    /*获取事件对象*/
    getEvent: function (event) {
        return event ? event : window.event;
    },
    /*获取事件源*/
    getTarget: function (event) {
        return event.target || event.srcElement;
    },
    /*阻止默认事件*/
    preventDefault: function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    /*阻止事件派发*/
    stopPropagation: function (event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    },
    /*移除指定事件和对应的函数*/
    removeHandler: function (element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent(on + type, handler);
        } else {
            element['on' + type] = null
        }
    }
};
```

## 滚动条事件 

### onscroll

1. onscroll：当元素的滚动条滚动时触发的事件（前提一定要有滚动条）

   onscroll事件可以绑定任何实体元素，如DOM元素、window元素、document元素。

   用法即：element.onscroll=function(){};

2. scrollTop/scrollLeft：当前元素的左边缘/上边缘距离其上级层左边缘/上边缘的距离

   scrollTop属性只有DOM元素才有，window/document没有。

   用法1：获取值 var top = element.scrollTop;//返回数字，单位像素

   用法2：设置值 element.scrollTop = 200;

兼容性问题：获得整个文档scrollTop方式如下：

```js
 var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
//当页面滚动条刚好在最顶端，即scrollTop值为 0 时，IE 下 window.pageYOffset  (Safari) 返回为 undefine，而其他浏览器无论 scrollTop 赋值或运算顺序如何都不会返回 undefine.
//所以 window.pageYOffset  (Safari)   被放置在 || 的中间位置。
```

1. scrollHeight/scrollWidth：获取整个元素的宽度（包括滚动条隐藏的范围）/高度（包括滚动条隐藏的范围）和scrollTop属性一样，只有DOM元素才有，window/document没有。不同的是scrollHeight是只读，不可设置。

### window.scroll()，window.scrollBy()，window.scrollTo(),均是全局函数

用的不多，可能在IE/FF/CH各个版本支持不同,建议设置element.scrollTop属性的方法替代。

- window.scroll(x,y)是让window滚动条滚动到那个x,y坐标。//x是水平坐标，y是垂直坐标。
- window.scrollBy(-x,-y)是让window滚动条相对滚动到某个坐标，-10即相对向左/向上滚动10像素
- window.scrollTo(x,y)和window.scroll(x,y)一样。

### clientTop、scrollTop、offsetTop的区别

offsetTop/offsetLeft/offsetWidth/offsetHeight（只读）

- offsetTop/offsetLeft：指该元素 距离上方/左方的位置
- offsetWidth/offsetHeight：指该元素 自身的宽度/高度

![offset、scroll、client](E:\web\Typora\img/offset、scroll、client.gif)

 



## 监测页面是否切换到后台

- document.hidden（Boolean值，表示当前页面可见还是不可见）
- document.visibilityState（返回当前页面的可见状态。分为"hidden"跟"visible"）

```js
document.addEventListener("visibilitychange", function(){		 	 	     			if(document.visibilityState=="visible"){...}
	if(document.visibilityState=="hidden"){...}                                         })
```

## 监测浏览器窗口变化

```js
window.addEventListener('resize', function(e) {
    // do something
})
```



# 面向对象

Object Oriented Programming：  面向对象编程

Object Oriented Analysis： 面向对象分析

Object Oriented Design： 面向对象设计

## 概念

+ 什么是对象：万物皆对象，比如一辆车，它有颜色、形状，还有些功能，如：能够行驶，能够发出声音等，而面向对象是我们去解决问题的一种思维方式，比如我去生产一辆车，我不用去关注它生产过程中的每个细节，只要生产出的车符合要求就行，那我们只需要去找采购部门去领所需要零件，然后再找懂组装车、焊接的等一些师傅去完成最终得到我们想要的结果

+ 好处

  + 它有更好的灵活性和可维护性。

  + 模块化，使代码更简单、更容易理解。

+ 三大特征：封装、继承、多态
  + 封装：1、提炼成函数-------2、组织成对象
  + 继承：一个对象自己没有的属性和方法，但是其他对象有，把其他对象的属性和方法弄过来使用，就是继承。

## 创建函数

### 添加属性（方法）的两种形式

==点和['属性名']==

+ obj.fn = function(){console.log("...");}
+ obj["age"]=20、obj["fn"] = function(){console.log("...");}

### 字面量形式：{key:value}

把多个属性和方法封装在一个对象内，缺点是创建多个实例对象会造成代码冗余

+ 优点：简单
+ 缺点：一次只能创建一个对象，数量太多时会造成代码冗余

### 使用内置构造函数Object

var obj = new Object()

- 优点：创建对象简单方便
- 缺点：创建的对象是空对象，仍需动态赋值，代码冗余度依然很多

## 封装

### 函数封装

把多个属性和方法封装在一个函数内，然后生成实例对象，就等于是在调用函数

+ 简单工厂函数

  ```js
  function  createPerson(){
      var person = new Object();
      person.id = 10086;
      person.name = "lisi";
      person.career= "歌手";
      return person;
  }
  var p = createPerson();
  ```

+ 带参数的工厂函数

  ```js
  function  createPerson(id, name, career){
      var person = new Object();
      person.id = id;
      person.name = name;
      person.career= career;
      return person;
  }
  var p1 = createPerson(10010,"小强","歌手");
  var p2 = createPerson(10086,"小宋","经纪人");
  ```

### 自定义构造函数

+ 通常用来构建对象。规则是使用new关键字+构造函数来创建对象==new Function()==

==如果构造函数不和new一起使用,就相当于常规的函数调用,其中的this指向的是window==

+ 构造函数通常首字母大写

+ 构造函数的执行过程如下：
  + 调用构造函数，系统默认创建一个对象，并且把这个对象赋值给了this关键字。（此时this就指向了系统默认创建的对象）
  + 使用this来给新对象添加属性和方法。
  + 默认返回新创建的对象。

+ 构造函数返回值问题
  + 默认返回新创建的对象;
  + 如果return值类型,return语句没有效果
  + 如果return引用类型,那么结果会返回这个引用类型，而不是默认的this对象。

```js
function  Person(id, name, career){
    this.id = id;
    this.name = name;
    this.career= career;
    this.sayHello = function(){ console.log("hello world!");}
    // return 12;
    // return {id:"假对象"};
}
var p = new Person();
```

### 原型方法

通过prototype属性给对象动态添加属性和方法

## 原型

### 概念

+ 什么是原型：构造函数默认关联了一个prototype属性，这个属性指向的对象就称为原型。实际上所有函数都有这个属性。

+ 原型的作用：原型中的属性和方法能够被实例化的所有对象共享

+ 原型的访问方式
  + 方式1: 构造函数通过prototype属性来访问原型对象
  + 方式2: 实例对象通过`__proto__`属性来访问原型对象

  ==不推荐使用方式2。因为不是w3标准的属性,平时做调试可以用。一般不要通过对象实例`__proto__`去对原型做修改。（不好排bug）==

+ 原型解决问题方法：构造函数的原型对象中的属性和方法能被实例对象所访问，所有将构造函数中需要创建函数（方法）的地方，都通过prototype属性添加即可

### 使用方法

+ 利用对象的动态特性给原型对象添加成员

+ 直接替换原型：原型替换之前创建的对象和替换原型之后创建的对象，他们指向不同的原型对象;所以可能会有不同的方法。

```js
function  Person( name,age){ this.name = name; this.age = age;}
Person.prototype.sayHello = function(){console.log(this.name + " say hello world!");}
var p1 = new Person("小强",33);
Person.prototype = {
    msg:"信息",
    hobby:function(){ console.log("我就是哎跳舞"); }
}
var p2 = new Person("小吉",13);

p1.sayHello(); //在改变原型对象之前，已实例化对象，所以可以执行此方法
p2.sayHello();//报错，在改变原型对象之后实例化对象，对象已变，所以属性方法也会发生改变
console.log(p1.msg); //undifend，实例化对象时，并无此属性
console.log(p2.msg); //信息
```

==使用的注意事项==

+ 使用对象访问属性的时候，如果在本身的属性内找不到，就会去原型中查找。但是通过实例对象去修改或赋值后，它不会优先去原型中查找，所以它会优先在对象本身内去寻找属性。

+ 如果原型中属性是引用类型的属性。那么所有对象共享该属性，并且一个对象修改了该引用类型属性中的成员，其他对象也会受影响。

  ```js
  function Person(){}
  Person.prototype.name = "小张";
  Person.prototype.age = 18;
  Person.prototype.pet = { brand:"lbld", age:20 }
  var p1 = new Person;
  var p2 = new Person;
  p1.name ="李四";
  console.log(p1.name);//李四
  console.log(p2.name);//小张
  p1.pet.brand = "jinmao";
  console.log(p1.pet.brand);//jinmao
  console.log(p2.pet.brand);//jinmao
  ```

### constructor

此属性是系统自带的，如果使用新对象替换默认的原型后，新原型对象中就没有constructor属性了

为了保持 构造函数 --- 原型 ----- 实例对象 3者之间的合理关系

我们应该在替换原型后，给新原型对象手动添加constructor属性，通过此属性可以找到实例对象的构造函数

### 属性搜索机制

+ 属性搜索机制：也就是属性的查找顺序

+ 属性的查找顺序
  + 首先在当前对象中查找，找到就停止，否则继续下一步
  + 到对象的原型中查找，找到就停止，否则继续下一步
  + 到对象的原型的原型中查找，找到就停止，否则继续下一步。
  + 一直往上查找，直到查找到Object.prototype。如果没有那么属性就返回 undefied，方法就报错xxx is not a function的错误。

+ 属性屏蔽

  属性屏蔽就是==对象本身的属性==和==原型中的属性名称一样==的时候，根据属性搜索原则，会首先找到==本身的属性==。找到以后就不会去找原型中的属性了。这个情况就是属性屏蔽

  如果不想遵守属性搜索机制，可以通过原型对象去访问被屏蔽的属性或者删除本身的属性（不会删除原型对象中的）

  ```js

  ```

## 继承

### 混入式继承（拷贝式继承）（for in）

  ```js
var o = {};
var obj = {
    id:10010,
    name:"xiaoqiang",
    sayHello:function(){ console.log("HELLO WORLD!"); }
}
for (var k in obj){
    o[k] = obj[k];
}
o.sayHello === obj.sayHello;//true
  ```

### 原型继承

+ 原型继承：它是利用原型中的属性和方法可以被相关对象共享的特性来实现继承

==注：如果想要一个内置对象的所有功能并且添加其它功能，那么需要自定义一个对象去继承这个内置对象，不要在内置对象上进行扩展==

==注：通过原型继承时，如果多个对象的原型对象指向所继承对象的实例化对象的变量，则改变一个原型对象的属性或方法，就会影响其它的对象，为此，原型对象需要指向通过new Object或内置对象简写==

```js
var arr = [];
function Aarray(){
    this.sayHello = function(){console.log("我是A的HELLO");}
}
Aarray.prototype = [];//Aarray继承[]对象之后,就有了数组对象的所有属性和方法.
Aarray.prototype = new Array();//同上
Aarray.prototype = arr;//如果指向arr，它是数组的一个实例对象，如果通过原型改变属性或方法就会影响其它指向arr的对象的原型成员;

function Barray(){
    this.sayHello = function(){console.log("我是B的HELLO");}
}
Barray.prototype = [];//Barray继承[]之后,就有了数组的所有属性和方法.
Barray.prototype.add = function(){console.log("我是b的add方法!");}

var a = new Aarray ();
var b = new Barray();

a.sayHello();
a.push(4,5,6);
b.sayHello();
b.push(6,7,8);
a.add();//如果函数Barray的原型指向arr，就会获取此方法，否则找不到
console.log(a);
console.log(b);
```

#### 替换原型

相当改变当前对象的原型对象，那么之前的原型对象下的属性和方法将会访问不到

```js
function Parent() {
    this.name = '12';
    this.sayHi = function(){ console.log("Hi World!"); }
}
function  Person(){ // this.name = '23'; }
    Person.prototype.sayHello= function (){ console.log("Hello World!"); }
    Person.prototype = new Parent();//改变了Person的原型对象
    var p = new Person();
    p.sayHello();//报错
    console.log(p.name);//查看属性搜索机制原则
    p.sayHi();
}
```
#### 通过拷贝向原型对象添加成员,没有改变原型对象

```js
function  Person(name){ this.name = name; }
Person.prototype.sayHello= function (){ console.log("Hello World!"); }
var parent = { sayHi:function(){ console.log("Hi World!"); } }
for(var key in parent){ Person.prototype[key] = parent[key]; }
var p = new Person();
p.sayHi();//Hi World!
p.sayHello();//Hello World! 
```

#### 传参继承：替换原型

```js
function jicheng(obj){
    function F() {};
    F.prototype = obj;
    var f = new F();
    return f;
    // var o = {};
    // o.proto = obj; //做原型替换
    // return o;
}
var newObj = jicheng({name:"zhansan"});
newObj.name ="lisi";
console.log(newObj);
```
#### Object.create(object):替换原型

```js
function jicheng(obj){
    if(Object.create){
        return Object.create(obj);
    }else{//兼容IE8以前
        Object.create = function(obj){
            function F(){};
            F.prototype = obj;
            var f = new F();
            return f;
        }
        return Object.create(obj);
    }
}
var newObj = jicheng(obj);
console.log(newObj);
```
# Object

## create

==创建的对象在对象的原型上==

```js
const o = Object.create({ x: 1, y: 2 });
o.z = 3;
console.log(o)	//	{ z: 3 }
console.log(o.__proto__)	//	{ x: 1, y: 2 }
let { x, ...newObj } = o;	//	reset只能
console.log(x)	//	1
console.log(newObj)	//	{ z: 3 }
```



## hasOwnProperty()

==用来判断对象本身（不包括原型链上）是否拥有某个属性==

==如果使用for-in遍历对象，可以通过此属性来区分对象本身和原型上可枚举的属性==

```js
function Person(){ this.name = "zhangsan";}
Person.prototype.age = 18;
var p = new Person();
console.log(p.hasOwnProperty("name"));//true
console.log(p.hasOwnProperty("age"));//false
console.log(p.hasOwnProperty("__proto__"));//false比较特殊，虽然每个对象都有，但不是对象本身的属性。
```

## isPrototypeOf()

==用来判断一个对象是否在另外一个对象的原形链中==

```js
function Person(){ this.name = "zhangsan"; }
function Human(){}
var h = new Human();
Person.prototype = h;//new Human();
Person.prototype.constructor = Person;
var p = new Person();
console.log(h.isPrototypeOf(p));//true
console.log(Human.prototype.isPrototypeOf(p));//true
console.log(Object.prototype.isPrototypeOf(p));//true
```

## toString()、valueOf()、toLocaleString

==当对象参数运算的时候，会调用对象的valueOf方法,如果没有这个方法，就调用toString这个方法==

```js
var  now = new Date();
console.log(now);//Mon Apr 09 2018 19:26:53 GMT+0800 (中国标准时间)
console.log(now.toLocaleString());//2018/4/9 下午7:26:53

function Person(name, age, amount) {
    this.name = name;
    this.age = age;
    this.amount = amount;
    this.toString = function () {
        return this.amount;
    }
    this.valueOf = function () {
        return this.age;
    }
}
var data = [
    new Person('弋 痕 兮 ', 36, 400),
    new Person('辰 月 ', 18, 122),
    new Person('山 鬼 瑶 ', 38, 456),
    new Person('百里登风', 20, 166),
    new Person('单 雨 童 ', 24, 255),
    new Person('上官云阙', 48, 600)
];
//优先调用valueOf()方法
data.sort(function (a, b) {
    return a - b;
})
console.log(data);
console.log(eval(data.join('+')));
```

## Object.defineProperty

添加属性的时候，可以附加一些信息，比如是否可读写权限，数值范围等!

## 可枚举属性和不可枚举属性

### 总结

+ ==JavaScript对象的属性可分为可枚举和不可枚举，它是由属性的enumeration值决定的，true为可枚举，false为不可枚举==

+ ==js中原型属性一般是不可枚举的，而自己定义的属性一般是可枚举的==

+ ==可以通过propertylsEnumerable()方法判断该属性是否可枚举==

+ ==属性的枚举性会影响以下三个函数的结果==

  + for...in：遍历原型与实例上的所有可枚举属性
  + Object.keys()：只能返回对象本身具有的可枚举属性
  + JSON.stringify()：只能读取对象本身的可枚举属性，并序列化为JSON对象

  ```js
  function Person() { this.name = "KXY"; }
  Person.prototype = {
      constructor: Person,
      job: "student",
  };
  var kxy = new Person();
  Object.defineProperty(kxy, "sex", {
      value: "female",
      enumerable: false
  });
  //for-in
  for(var key in kxy) {console.log(key)} //	name,constructor,job,没有sex
  //Object.keys()
  console.log(Object.keys(kxy)) //	name	只能返回对象本身具有的可枚举属性
  //JSON.stringify
  console.log(JSON.stringify(kxy)) //	name	只能读取对象本身的可枚举属性，并序列化为JSON对象
  ```

### enumerable--设置是否可枚举

+ JavaScript对象的属性是否可枚举是enumeration的值决定的，enumeration是 Object.defineProperty()方法的一个参数

+ enumerable为true表示可枚举，enumerable为false表示不可枚举
+ 开发者自定义的对象person的所有属性都是可枚举的

```js
Object.defineProperty(obj, prop, descriptor)
第一个：目标属性所在的对象，
第二个：目标属性，放在字符串里，
第三个：目标属性的行为，放在对象里；
var person = {
    name:'zhou',
    age: '12',
    sex: 'girl'
}
Object.defineProperty(person,'age',{
    enumerable:true,//可以被枚举
});
```

### propertyIsEnumerable--判断是否可枚举

+ 语法：obj.propertyIsEnumerable(prop) ==用来判断对象本身是否包含某个属性且这个属性是否可枚举==
+ 每个对象都有一个propertyIsEnumerable方法。此方法可以确定对象中指定的属性是否可枚举，返回一个布尔值。但该方法对通过原型链继承的属性无效(==原型链继承的属性是否可枚举不能用该方法来判断==)
+ ==开发者自定义的属性在一般情况下是可枚举的，而内置对象原型属性是不可枚举的==
+ ==只对对象自身的属性(对象自身添加的、构造函数实例化的)有效，对原型上的、继承来的属性都无效==

```js
function Person(){ this.name = "zhangsan"; }
function Human(){ this.age = 18; }
Person.prototype = new Human();
Person.prototype.constructor = Person;
var p = new Person();
console.log(p.propertyIsEnumerable("name"));//true
console.log(p.propertyIsEnumerable("age"));//false
```



# Function对象

### 声明方式

+ 直接声明函数	    function  fun(a,b){ return a+b; }

+ 函数表达式     var add = function (){ console.log(10); }     add();

+ 使用构造函数 var f = new Function('x','y','函数体或者指向函数体')

  最后一个参数是函数的执行体，其他的是定义的函数的参数。(执行体优先，函数可以没有参数，但是不能没有函数体(没函数体的函数就没有意义))
  + <s>var fun = new Function("a","b","console.log(a+b)");不推荐</s>

  + 模板字符串code=``

    ```js
    var code = `
        var max=arr[0];
        for(var i=1; i< arr.length; i++){
            if(max<arr[i]){
                max=arr[i];
            }
        }
        console.log(max);
    `;
    var finMax = new Function("arr",code);
    finMax(arr);
    ```

  + 模板代码块：使用script标签，type="text/template"

    ```js
    window.onload= function(){
        var myCode = document.getElementById("myCode").innerHTML;;
        var finMax = new Function(myCode);
        finMax();
    }
    <script type="text/template" id="myCode">
        var max=arr[0];
        for(var i=1; i< arr.length; i++){
            if(max<arr[i]){
                max=arr[i];
            }
        }
    	console.log(max);
    </script>
    ```

### arguments对象

+ arguments 是一个对应于传递给函数的参数的类数组对象。

+ arguments对象在函数调用的时候，会将传入的实参保存起来。通过arguments[下标] 形式获取属性

+ arguments.length; 就是记录函数调用时，传入的实参个数

+ arguments.callee; 指代函数本身。对于一些匿名函数，一般做递归调用

### 静态成员和实例成员

+ 静态成员:通过函数名去访问的属性和方法就是静态成员。

+ 实例成员:通过实例对象去访问的属性和方法就是实例成员。

==实例对象不能访问静态成员，构造函数不能访问实例属性==

```js
function Person(){
    this.name = "zhangsan";
    this.age = 18;
}
var p = new Person();
console.log(p.name); //这里的name就是实例成员.
//sayHello就是静态成员.
Person.sayHello = function(){
    console.log(" wo shi yige static method！");
}
console.log(Person.age);//undefined //这个是构造函数的名字，不是实例对象的名字
console.log(p.sayHello);//undefined
```

### instanceof

第一个参数是对象，第二个参数是构造函数。对象的原型链上，是否有构造函数的原型

# 类数组对象

特性：有length属性，其它属性（索引）为非负整数，不具有数组所具有的方法

==在JS的DOM中，有三个常用到的类数组对象：NodeList  NamedNodeMap 和 HTMLCollection==

==HTMLCollection  NodeList以及NamedNodeMap都是“动态的”，每当文档结构发生变化时，他们都会得到更新，始终会保存着最新，最准确的信息==

与数组的区别

+ 类数组是对象，不是数组，不能去使用数组中的方法
+ 添加成员时，类数组的length属性值不会变化
+ 设置length属性值时，数组的成员会发生变化，而类数组只是仅仅改变了length的属性值

## 类数组判断

```js
function isArrayLike(o) {
    if (o &&                                // o is not null, undefined, etc.
        typeof o === 'object' &&            // o is an object
        isFinite(o.length) &&               // o.length is a finite number
        o.length >= 0 &&                    // o.length is non-negative
        o.length===Math.floor(o.length) &&  // o.length is an integer
        o.length < 4294967296)              // o.length < 2^32
        return true;                        // Then o is array-like
    else
        return false;                       // Otherwise it is not
}
```

## 类数组转换

```js
Array.prototype.slice.call(listArray)
```

## 常见类数组对象

### arguments

+ 属性
  + length
  + callee

### NodeList

+ 属性
  + length

+ 方法
  + item(idx)：通过索引访问节点

以下返回类型为nodeList

```js
childNodes 
getElementsByClassName(className)  
getElementsByTagName(tagName)
```

### NameNodeMap

+ 属性
  + length

+ 方法
  + item(idx) 通过索引访问节点
  + getNamedItem(NS) 通过名称（和命名空间）访问节点 
  + setNamedItem(NS) 通过名称（和命名空间）设置节点 
  + removeNamedItem(NS) 根据名称（和命名空间）删除节点

以下代码形式返回类型为NamedNodeMap：

``` js
element.attributes
```

### HTMLCollection

- 属性
  - length

- 方法
  - item(idx) 通过索引访问节点
  - namedItem(name) //通过name 属性或 id 属性访问节点

以下代码形式返回类型为HTMLCollection：

``` 
document.images //所有img元素  
document.links //所有带href属性的a元素和area元素  
document.anchors //所有带name属性的a元素  
document.forms //所有form元素  
document.scripts //所有script元素  
tBodies(table元素)
rows(table、tbody、thead、tfoot元素)
cells(tr元素)
```

# 作用域

## JS作用域规则

- 函数允许访问函数外的数据，但函数外不能访问函数内部定义的数据
- 在代码结构中，只有函数可以限定作用域
- 作用域规则首先使用提升规则分析
- 如果出现相当的变量名时，优先使用内部的变量
- 在es5以前没有块级作用域，并且产生的作用域只有函数

## 词法作用域和动态作用域

## 作用域链

![](E:\web\Typora\img\作用域链.png)

- 作用域链：函数都有作用域，函数内部的作用域可以访问函数外部的作用域，当多个函数嵌套的时候，就会形成一个链式的结构，即作用域链
- 变量搜索规则
  - 首先会在当前作用域查找此变量，找到直接使用
  - 若没有在当前找到，则会去上一级作用域查找
  - 同上，一直找到全局作用域，若还没找到，直接报错

## 变量提升

- 变量提升：JavaScript引擎在对JavaScript代码进行解析执行之前，会对代码进行预解析，在预解析阶段，会将以关键字var和function开头的语句块进行提前处理

### 函数提升

- 在执行前，函数定义块会先进行提升处理

```js
func(); //在执行前，func函数定义块会先进行提升处理。
function func(){ console.log("我被调用了!");}
//提升后：
function func(){ console.log("我被调用了!"); }
func();
```

### 变量提升

- 只提升变量声明，不提升变量赋值

```js
console.log(a);//undefined
var a = 100;
//提升后：
var a;
console.log(a);
a = 100;
```

### 函数表达式提升

- 只提升变量名，不提升变量赋值

```js
fun();//报错 Uncaught TypeError:fun is not a function
var fun  = function(){
    console.log("我是一个匿名的函数!");
}
//提升后：
var fun;
fun();
fun = function(){
    console.log("我是一个匿名的函数!");
}
```

### 函数和变量同名

- 同名时，只提升函数，不提升变量

```js
console.log(typeof(foo));//function
var foo = 100;
function foo() { console.log("我被调用了") }
//提升后：
function foo() { console.log("我被调用了") }
console.log(typeof(foo));
foo = 100;
```

### 函数同名

- 后者将会覆盖前者

## 作用域内提升

```js
var num = 123;
var abc = 777;
function test(){
    console.log(num);//undefined
    console.log(abc);//777
    var num = 456;
    abc = 888;
}
test();
console.log(num);//123
console.log(abc);//888
//提升后
var num;
var abc;
function test(){
    var num;
    console.log(num);
    console.log(abc);
    num = 456;
    abc = 888;
}
num = 123;
abc = 777;
test();
console.log(num);//123
console.log(abc);//888
```

## undefined和not defined

- 变量声明没有赋值：返回undefined
- 变量未声明：报错not defined
- 在函数中，若查找属性，没有就返回undefined

## 变量提升易错示例

```
​```js
```

//在es5中没有块级作用域，所以判断语句形成不了块级作用域，因此引擎依然会先进行变量提升
if("a" in window){
​    var a = 10;
}
console.log(a); // 10
//提升后的代码：
var a;
if("a" in window){
​    a = 10;
}
console.log(a);
​    ```

```js
//原理同上，当前作用域为函数bar所形成的作用域内进行变量提升
var foo = 1;
function bar(){
    if(!foo){
        var foo = 10;
    }
    console.log(foo);//10
}
bar();
提升后的代码：
var foo;
function bar(){
    var foo;
    if(!foo){
        foo = 10;
    }
    console.log(foo);
}
foo = 1;
bar();
```

```js
//此处注意，函数a提升后，但此时的a已经被function声明了，即作用域也只在函数b内，外部将无法访问，即使对a重新做赋值操作，外部也无法访问函数b内部的变量
var  a=1;
function b() {
    a=10;return;
    function a() {}
};
b();
console.log(a)
//提升后
var a;
function b() {
    function a() {};
    a = 10;return;
}
a = 1;
b();
console.log(a);
```

# 函数调用（this&call&apply）

## 函数模式

- 简单的函数调用是函数名前没有任何引导内容（也就是没有对象去调用此函数）
- 此种情况下this指向window，在严格模式下指向undefined

## 方法模式

- 方法一定是依附于一个对象,将函数赋值给对象的一个属性, 那么就成为了其方法
- 此种情况下this指向调用此方法的对象

## 构造函数调用模式

- 使用 new 关键字, 来引导构造函数
- 构造函数中的this与方法中一样, 指向对象。 但是构造函数中的对象是刚刚创建出来的对象

## 上下文调用模式

### this

### call

fn.call(对象，arg1,arg2,arg3...)

### apply

fn.apply(对象，数组)

# [内置对象](http://www.runoob.com/jsref/dom-obj-document.html) 

## Array

### 获取数组中最后的元素

```js
array.slice(-1)
array.slice(-1)[0]
```

### 打乱数组元素的顺序

```js
arr.sort(function() { Math.random() - 0.5 })
```

### 伪数组转换为真数组

```js
Array.prototype.slice.call(arrayLike)
Array.from( elements )
```

### 合并数组

 Array.concat()**这个函数并不适用于合并大的数组，因为它需要创建一个新的数组，而这会消耗很多内存**

```js
arr1.push.apply( arr1, arr2 )
```



## Date



# DOM对象 [dom](http://www.runoob.com/jsref/dom-obj-document.html)

**DOM（document object model）**

## 增，删，改，查

- createElement()：创建标签，括号内需填写合法标签(eg：element=document.createElement('li');)
- appendChild():给指定标签添加一个子标签且添加在最后面（eg：ul.appendChild(element);)
- insertBefore(newNode,目标)：给指定内容前面插入内容（eg：ul.insertBefore(element,lis[i]);)
- replaceChild(newNode,目标）：把指定的目标给替换掉（eg：ul.replaceChild(element,lis[i]);)
- removeChild(目标)：删除某个元素的子元素（eg：ul.removeChild(lis[i]);)
- remove()：删除某个元素（eg：ul.remove();lis[i].remove();）

## DOM获取节点 

nodeName：获得当前节点的名称

下面为获取节点包括文本（如空格）

- parentNode     ：父节点
- nextSibling    ：后面一个节点
- previousSibling：前面一个节点
- childNodes     ：找到所有节点及文本（内容）并保存为数组
- firstChild     ：第一个节点
- lastChild      ：最后一个节点

下面为获取的节点为标签节点（不包含文本）

- children              ：获取所有标签节点，但不包含文本（内容）
- nextElementSibling    ：后面一个标签节点
- previousElementSibling：前面一个标签节点
- childElementNodes     ：找到所有标签节点并保存为数组
- firstElementChild     ：第一个标签节点
- lastElementChild      ：最后一个标签节点

原生js添加或删除类名

+ 添加一个类：document.getElementById("myDIV").classList.add("mystyle");
+ 添加多个类：document.getElementById("myDIV").classList.add("mystyle", "anotherClass", "thirdClass");
+ 移除一个类：document.getElementById("myDIV").classList.remove("mystyle");
+ 移除多个类：document.getElementById("myDIV").classList.remove("mystyle", "anotherClass", "thirdClass");
+ 检查是否含有某个CSS类：myDiv.classList.contains('myCssClass'); //return true or false

## 事件对象

### 表单事件

+ oninput：事件在用户输入时触发

# **BOM对象**

## window对象

- window.alert()：警告
- window.prompt()：输入
- window.confirm()：确认框（确认返回true,取消返回false）
- window.close()：关闭浏览器
- window.scrollTo(x,y)：每次触发时，移动指定位置
- window.scrollBy(x,y)：每次触发时，移动一定位移
- window.setInterval(),window.clearInterval(),window.setTimeout(),window.clearTimeout();

## window.location

window.location是一个对象，包含属性有

+ hash 从井号 (#) 开始的 URL（锚）
+ host 主机名和当前 URL 的端口号
+ hostname 当前 URL 的主机名
+ href 完整的 URL,获取window.location.href是最常用的
+ pathname 当前 URL 的路径部分
+ port 当前 URL 的端口号
+ protocol 当前 URL 的协议
+ search 从问号 (?) 开始的 URL（查询部分）

location是location.href的简写，无论是访问还是赋值，从功能上，locatin等于location.href

而从本质上，location是一个对象，location.href是一个属性

window.parent.length 属性返回在当前窗口中frames的数量（包括IFRAMES）

页面跳转和刷新：
history.go(0)
location.reload()
location = location
 location.replace(location)
window.location.href=window.location.href


# 闭包

个人理解：闭包就是能够读取其它函数内部变量的函数

本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 

最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 

# IIFE

IIFE: Immediately Invoked Function Expression，意为立即调用的函数表达式，也就是说，声明函数的同时立即调用这个函数 

## 作用

1、IIFE的出现是为了弥补JS在scope方面的缺陷：JS只有全局作用域（global scope）、函数作用域（function scope），从ES6开始才有块级作用域（block scope）。

2、在JS中，只有function，只有function，只有function才能实现作用域隔离，因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。

## 用法

写法一：

```js
(function foo(){})();
```

写法二：

```js
(functionfoo(){}());
```

### 

# 表单

elements

获取form表单内的子元素（只能获取和表单组合使用的元素）得到的是个数组

form.elements[name='user'].value：通过元素的name属性值来找到对应的元素（省去设置id/class）



# 同源VS跨域

## 同源

同源的标准

+ 协议相同
+ 域名相同
+ 端口相同

```html
//示例：对比 http://www.example.com/dir/page.html
http://www.example.com/dir2/other.html：同源
http://example.com/dir/other.html：不同源（域名不同）
http://v2.www.example.com/dir/other.html：不同源（域名不同）
http://www.example.com:81/dir/other.html：不同源（端口不同）
```

限制范围

（1） Cookie、LocalStorage 和 IndexDB 无法读取

（2） DOM 无法获得

（3） AJAX 请求不能发送

# 综合案例

+ 变量提升，构造函数，原型，this，作用域

```js
var a;
function Foo(){
    a = 200;
    getName = function(){ console.log(1); }
    return this
}
function getName(){ console.log(4); }

Foo.getName = function(){console.log(2)}//静态的
Foo.prototype.getName = function(){ console.log(3); }//原型的
getName = function (){ console.log(5); }
a =100;

console.log(a);//100
Foo.getName(); //2 	调用Foo的静态属性
getName(); //5
Foo();//执行后返回window对象，它改变了全局变量getName()，window下只有Foo()里的getName()
Foo().getName(); //1 等同于Foo();getName();
console.log(a);//200
window.getName();//1
getName(); //1
new Foo.getName(); //2 	先执行Foo.getName(),再new
new Foo().getName();//3 先执行new Foo()，再.getName()
```



## 

















# 。

# 。

# 。

# 。

# .

# .

# 。

# 。

# 。

# .

# .

# 。

# .

# 。

# .

# 。

# 。

# .

# .



















































































































































